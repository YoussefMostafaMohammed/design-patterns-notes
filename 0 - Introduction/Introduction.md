# Introduction

Modern software development is full of recurring problems—problems that appear across different projects, teams, and programming languages. A **design pattern** is a proven, reusable solution to one of these common problems. Patterns represent standard ways to structure programs, organize components, and build relationships between objects.

Unlike techniques, which are often tied to the specifics of a programming language, **design patterns are language-agnostic**. A pattern can be applied in C++, C#, Java, Python, or any object-oriented language. In contrast, a *technique* is usually tied to a particular language feature (for example, C++ move semantics or template metaprogramming).
This repository focuses on *both*—the timeless patterns used in all OOP languages, and the powerful techniques unique to Modern C++ (C++11–C++23).

One of the biggest advantages of design patterns is that **they have names**. When developers say things like *Factory*, *Observer*, *Singleton*, or *Strategy*, the names instantly convey structure, intent, and behavior. This shared vocabulary makes it easier to communicate solutions and understand designs quickly.

However, the naming ecosystem is not always consistent. Different books or sources sometimes use different names for the same idea, or define boundaries between patterns differently. With few exceptions, the terminology used here follows the classic reference:

**Design Patterns: Elements of Reusable Object-Oriented Software**
*Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides — 1994*
(also known as the “Gang of Four” or **GoF** book)

Still, alternative names and variations are mentioned when relevant.

Design patterns are powerful, but they are not absolute rules. **Good design is a conversation**, not a prescription. Use these patterns as inspiration—not as rigid formulas. Adapt them, refine them, and build upon them to construct solutions that fit your project’s needs.
